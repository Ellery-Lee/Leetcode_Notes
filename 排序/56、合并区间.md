# 56、合并区间

- 题目要求：给出一个区间的集合，请合并所有重叠的区间。

- ```
  输入: [[1,3],[2,6],[8,10],[15,18]]
  输出: [[1,6],[8,10],[15,18]]
  解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].
  
  输入: [[1,4],[4,5]]
  输出: [[1,5]]
  解释: 区间 [1,4] 和 [4,5] 可被视为重叠区间。
  ```



## 方法一：排序算法 95.22%

```java
class Solution {
    public int[][] merge(int[][] intervals) {
        if(intervals == null || intervals.length == 0){
            return new int[0][0];
        }
        //注意比较器的写法
        Arrays.sort(intervals, new Comparator<int[]>(){
            //override
            public int compare(int[] a, int[] b){
                return a[0] - b[0]; 
            }
        });
        //list存储不重叠区间
        List<int[]> ans = new ArrayList<>();
        int lk = 0;
        int rk = 0;
        //后一个区间的左边界小于等于当前区间右边界可以继续扩大
        //否则将区间加入list
        for(int i = 0; i < intervals.length; i++){
            lk = intervals[i][0];
            rk = intervals[i][1];
            while(i+1 < intervals.length && intervals[i+1][0] <= rk){
                //扩大右边界时要判断后区间的有边界不能小于当前右边界
                //否则区间缩小了
                rk = Math.max(intervals[++i][1], rk);
            }
            ans.add(new int[]{lk, rk});
        }
        //将list转为Array返回
        return ans.toArray(new int[ans.size()][2]);
    }
}
```

- 时间复杂度：O(N*log(N))，排序为O(N*log(N))，遍历为O（n）,排序占主要地位。
- 空间复杂度：O（log(n)）,除答案外排序使用的额外空间。
- **思路**：对数组的区间左端点进行排序，这样可以保证区间左端点是连续升序的，遍历中判断当前区间左端点和之前的右端点大小，如果小于等于就需要合并，并再次更新右端点大小。https://leetcode-cn.com/problems/merge-intervals/solution/he-bing-qu-jian-by-leetcode-solution/



- timeline

1. ~~2020.7.11-~~
2. 2020.7.12
3. 2020.7.13
4. 2020.7.18
5. 2020.7.25
6. 2020.8.9