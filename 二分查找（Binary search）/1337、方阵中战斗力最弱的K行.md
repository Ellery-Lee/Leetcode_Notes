# 1337、方阵中战斗力最弱的K行

- 题目要求：给你一个大小为 m * n 的方阵 mat，方阵由若干军人和平民组成，分别用 1 和 0 表示。请你返回方阵中战斗力最弱的 k 行的索引，按从最弱到最强排序。如果第 i 行的军人数量少于第 j 行，或者两行军人数量相同但 i 小于 j，那么我们认为第 i 行的战斗力比第 j 行弱。军人 总是 排在一行中的靠前位置，也就是说 1 总是出现在 0 之前。

- ```
  示例1：
  输入：mat = 
  [[1,1,0,0,0],
   [1,1,1,1,0],
   [1,0,0,0,0],
   [1,1,0,0,0],
   [1,1,1,1,1]], 
  k = 3
  输出：[2,0,3]
  解释：
  每行中的军人数目：
  行 0 -> 2 
  行 1 -> 4 
  行 2 -> 1 
  行 3 -> 2 
  行 4 -> 5 
  从最弱到最强对这些行排序后得到 [2,0,3,1,4]
  
  示例2：
  输入：mat = 
  [[1,0,0,0],
   [1,1,1,1],
   [1,0,0,0],
   [1,0,0,0]], 
  k = 2
  输出：[0,2]
  解释： 
  每行中的军人数目：
  行 0 -> 1 
  行 1 -> 4 
  行 2 -> 1 
  行 3 -> 1 
  从最弱到最强对这些行排序后得到 [0,2,3,1]
  ```

## 方法一：暴力解  75.74%

```java
class Solution {
    public int[] kWeakestRows(int[][] mat, int k) {
        int[] ans = new int[k];
        int count = 0;

        for(int j = 0; j < mat[0].length; j++){
            for(int i = 0; i < mat.length; i++){
                if(mat[i][j] == 0 && (j == 0? true: mat[i][j-1] != 0) && count < k){
                    ans[count++] = i;
                }
                if(count == k){
                    return ans;
                }

            }
        }

        if(count < k){
            for(int i = 0; i < mat.length; i++){
                if(mat[i][mat[0].length - 1] == 1){
                    ans[count++] = i;
                }
                if(count == k){
                    return ans;
                }
            }
        }

        return ans;
    }
}
```

- 时间复杂度：*O*（mn + m）m为行数，n为列数
- 空间复杂度：O(k）使用了一个额外k大小的数组
- **思路**：纵向扫描方阵，遇到0判断之前是否加入过，没有就加入答案数组。如果遍历完成仍然不够k个元素，说明方阵中没有k行农民，所以需要加入最后一列全军人，从上到下。



- timeline

1. ~~2020.6.25-~~
2. 2020.6.26
3. 2020.6.28
4. 2020.7.2
5. 2020.7.9
6. 2020.7.24