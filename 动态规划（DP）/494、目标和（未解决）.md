# 494、目标和

- 题目要求：给定一个非负整数数组，a1, a2, ..., an, 和一个目标数，S。现在你有两个符号 + 和 -。对于数组中的任意一个整数，你都可以从 + 或 -中选择一个符号添加在前面。

  返回可以使最终数组和为目标数 S 的所有添加符号的方法数。

- ```
  输入：nums: [1, 1, 1, 1, 1], S: 3
  输出：5
  解释：
  
  -1+1+1+1+1 = 3
  +1-1+1+1+1 = 3
  +1+1-1+1+1 = 3
  +1+1+1-1+1 = 3
  +1+1+1+1-1 = 3
  
  一共有5种方法让最终目标和为3。
  ```



## 方法一：回溯算法 5.02%

```java
class Solution {
    int ans = 0;
    public int findTargetSumWays(int[] nums, int S) {
        if(nums == null || nums.length == 0){
            return 0;
        }
        backtrack(nums, S, 0);
        return ans;
    }

    public void backtrack(int[] nums, int S, int start){
        if(start >= nums.length){
            if(S == 0){
                ans++;
            }
            return;
        }
        for(int i = 0; i < 2; i++){
            if(i == 0){
                backtrack(nums, S + nums[start], start+1);
            }else if(i == 1){
                backtrack(nums, S - nums[start], start+1);
            }
        }
        return ;
    }
}
```

- 时间复杂度：O（2^n^）穷举
  空间复杂度：O(1)，没有额外空间
- **思路**：回溯算法，暴力穷举，时间复杂度较高。



## 方法二 ：动态规划 不对为什么？？？

```java
class Solution {
    public int findTargetSumWays(int[] nums, int S) {
        if(nums == null || nums.length == 0){
            return 0;
        }
        int n = nums.length;
        int[][] dp = new int[n+1][S+1];
        for(int i = 0; i < n+1; i++){
            dp[i][0] = 1;
        }
        // dp[0][0] = ;
        for(int i = 1; i < n+1; i++){
            for(int j = 0; j < S+1; j++){
                if(nums[i-1] <= j){
                    dp[i][j] = dp[i-1][j] + dp[i-1][j-nums[i-1]];
                }else if(nums[i-1] >j){
                    dp[i][j] = dp[i-1][j];
                }
            }
        }
        return dp[n][S];
    }
}
```

- 时间复杂度：O(n* sum)
  空间复杂度：O(n* sum)
- **思路**：转化成背包问题。



## 方法三 ： 动态规划优化99.96%

```java
class Solution {
    public int findTargetSumWays(int[] nums, int S) {
        
        int len = nums.length;
        int sum = 0;
        for(int num : nums){
            sum += num;
        }
        //为奇数，则无解
        if(S > sum || (sum + S) % 2 != 0) return 0;
        //只需要找到和为 target 的 数组元素的集合
        //转化为背包问题，放入物品背包总价值为 target 的方案个数
        int target = (sum + S) / 2;
        //if(nums.length == 1 && nums[0] != target) return 0;
        int[] dp = new int[target+1];
        if(nums[0] <= target){
            dp[nums[0]] = 1;
        }
        //为0时有两种 +0 和 - 0
        dp[0] = nums[0] == 0 ? 2 : 1;
        for(int i = 1; i < len; i++){
            for(int j = target; j >= nums[i]; j--){
                //两种选择之和，放入num[j] 或者不放入
               dp[j] = dp[j] + dp[j-nums[i]];   
            }
        }
        return dp[target];
    }
}
```

- 时间复杂度：O(n* sum)
  空间复杂度：O(sum)
- **思路**：转化成背包问题。



- timeline

1. ~~2020.8.7-~~
2. 2020.8.8
3. 2020.8.9
4. 2020.8.14
5. 2020.8.21
6. 2020.9.5