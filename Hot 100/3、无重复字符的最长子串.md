# 3、无重复字符的最长子串

- 题目要求：给定一个字符串，请你找出其中不含有重复字符的 **最长子串** 的长度。

- 示例1:

  > ```
  > 输入: "abcabcbb"
  > 输出: 3 
  > 解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
  > ```

- 示例2：

  >```
  >输入: "bbbbb"
  >输出: 1
  >解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。
  >```

- 示例3：

  >```
  >输入: "pwwkew"
  >输出: 3
  >解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。
  >     请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。
  >```

## 方法一：滑动窗口法   37.01%

```java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        Set<Character> set = new HashSet<>();
        int ans = 0;
        int rk = 0;    //右指针
        for(int i = 0; i < s.length(); i++){
            if(i != 0){
                set.remove(s.charAt(i - 1));
            }

            while(rk < s.length() && !set.contains(s.charAt(rk))){
                set.add(s.charAt(rk));
                rk++;
            }
            ans = Math.max(ans, set.size());
        }
        return ans;
    }
}
```

- 时间复杂度：O(n)，左指针遍历所有字符。

- 空间复杂度：O(m), m为子串最大长度。

- **思路**：使用双指针法，设我们选择字符串中的第 k 个字符作为起始位置，并且得到了不包含重复字符的最长子串的结束位置为 rk。那么当我们选择第 k+1 个字符作为起始位置时，首先从 k+1 到 rk的字符显然是不重复的，并且由于少了原本的第 k个字符，我们可以尝试继续增大 rk，直到右侧出现了重复字符为止。这样以来，我们就可以使用**「滑动窗口」**来解决这个问题了：

  我们使用两个指针表示字符串中的某个子串（的左右边界）。其中左指针代表着上文中「枚举子串的起始位置」，而右指针即为上文中的rk；在每一步的操作中，我们会将左指针向右移动一格，表示 我们开始枚举下一个字符作为起始位置，然后我们可以不断地向右移动右指针，但需要保证这两个指针对应的子串中没有重复的字符。在移动结束后，这个子串就对应着 以左指针开始的，不包含重复字符的最长子串。我们记录下这个子串的长度。

  在枚举结束后，我们找到的最长的子串的长度即为答案。

**TimeLine:**

1. ~~2020.5.31-~~
2. 2020.6.1
3. 2020.6.3
4. 2020.6.7
5. 2020.6.14
6. 2020.6.29